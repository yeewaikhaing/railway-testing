import { DeepPartial, EntityManager } from "typeorm";
import { TransactionBaseService } from "../interfaces";
import { LineItem, Order, Return } from "../models";
import { ReturnRepository } from "../repositories/return";
import { ReturnItemRepository } from "../repositories/return-item";
import { FindConfig, Selector } from "../types/common";
import { OrdersReturnItem } from "../types/orders";
import { CreateReturnInput, UpdateReturnInput } from "../types/return";
import FulfillmentProviderService from "./fulfillment-provider";
import InventoryService from "./inventory";
import LineItemService from "./line-item";
import OrderService from "./order";
import ReturnReasonService from "./return-reason";
import ShippingOptionService from "./shipping-option";
import TaxProviderService from "./tax-provider";
import TotalsService from "./totals";
declare type InjectedDependencies = {
    manager: EntityManager;
    totalsService: TotalsService;
    lineItemService: LineItemService;
    returnRepository: typeof ReturnRepository;
    returnItemRepository: typeof ReturnItemRepository;
    shippingOptionService: ShippingOptionService;
    returnReasonService: ReturnReasonService;
    taxProviderService: TaxProviderService;
    fulfillmentProviderService: FulfillmentProviderService;
    inventoryService: InventoryService;
    orderService: OrderService;
};
declare type Transformer = (item?: LineItem, quantity?: number, additional?: OrdersReturnItem) => Promise<DeepPartial<LineItem>> | DeepPartial<LineItem>;
declare class ReturnService extends TransactionBaseService {
    protected manager_: EntityManager;
    protected transactionManager_: EntityManager | undefined;
    protected readonly totalsService_: TotalsService;
    protected readonly returnRepository_: typeof ReturnRepository;
    protected readonly returnItemRepository_: typeof ReturnItemRepository;
    protected readonly lineItemService_: LineItemService;
    protected readonly taxProviderService_: TaxProviderService;
    protected readonly shippingOptionService_: ShippingOptionService;
    protected readonly fulfillmentProviderService_: FulfillmentProviderService;
    protected readonly returnReasonService_: ReturnReasonService;
    protected readonly inventoryService_: InventoryService;
    protected readonly orderService_: OrderService;
    constructor({ manager, totalsService, lineItemService, returnRepository, returnItemRepository, shippingOptionService, returnReasonService, taxProviderService, fulfillmentProviderService, inventoryService, orderService, }: InjectedDependencies);
    /**
     * Retrieves the order line items, given an array of items
     * @param order - the order to get line items from
     * @param items - the items to get
     * @param transformer - a function to apply to each of the items
     *    retrieved from the order, should return a line item. If the transformer
     *    returns an undefined value the line item will be filtered from the
     *    returned array.
     * @return the line items generated by the transformer.
     */
    protected getFulfillmentItems(order: Order, items: OrdersReturnItem[], transformer: Transformer): Promise<(LineItem & {
        reason_id?: string;
        note?: string;
    })[]>;
    /**
     * @param selector - the query object for find
     * @param config - the config object for find
     * @return the result of the find operation
     */
    list(selector: Selector<Return>, config?: FindConfig<Return>): Promise<Return[]>;
    /**
     * Cancels a return if possible. Returns can be canceled if it has not been received.
     * @param returnId - the id of the return to cancel.
     * @return the updated Return
     */
    cancel(returnId: string): Promise<Return | never>;
    /**
     * Checks that an order has the statuses necessary to complete a return.
     * fulfillment_status cannot be not_fulfilled or returned.
     * payment_status must be captured.
     * @param order - the order to check statuses on
     * @throws when statuses are not sufficient for returns.
     */
    protected validateReturnStatuses(order: Order): void | never;
    /**
     * Checks that a given quantity of a line item can be returned. Fails if the
     * item is undefined or if the returnable quantity of the item is lower, than
     * the quantity that is requested to be returned.
     * @param item - the line item to check has sufficient returnable
     *   quantity.
     * @param quantity - the quantity that is requested to be returned.
     * @param additional - the quantity that is requested to be returned.
     * @return a line item where the quantity is set to the requested
     *   return quantity.
     */
    protected validateReturnLineItem(item?: LineItem, quantity?: number, additional?: {
        reason_id?: string;
        note?: string;
    }): DeepPartial<LineItem>;
    /**
     * Retrieves a return by its id.
     * @param id - the id of the return to retrieve
     * @param config - the config object
     * @return the return
     */
    retrieve(id: string, config?: FindConfig<Return>): Promise<Return | never>;
    retrieveBySwap(swapId: string, relations?: string[]): Promise<Return | never>;
    update(returnId: string, update: UpdateReturnInput): Promise<Return>;
    /**
     * Creates a return request for an order, with given items, and a shipping
     * method. If no refund amount is provided the refund amount is calculated from
     * the return lines and the shipping cost.
     * @param data - data to use for the return e.g. shipping_method,
     *    items or refund_amount
     * @return the created return
     */
    create(data: CreateReturnInput): Promise<Return | never>;
    fulfill(returnId: string): Promise<Return | never>;
    /**
     * Registers a previously requested return as received. This will create a
     * refund to the customer. If the returned items don't match the requested
     * items the return status will be updated to requires_action. This behaviour
     * is useful in sitautions where a custom refund amount is requested, but the
     * retuned items are not matching the requested items. Setting the
     * allowMismatch argument to true, will process the return, ignoring any
     * mismatches.
     * @param returnId - the orderId to return to
     * @param receivedItems - the items received after return.
     * @param refundAmount - the amount to return
     * @param allowMismatch - whether to ignore return/received
     * product mismatch
     * @return the result of the update operation
     */
    receive(returnId: string, receivedItems: OrdersReturnItem[], refundAmount?: number, allowMismatch?: boolean): Promise<Return | never>;
}
export default ReturnService;
